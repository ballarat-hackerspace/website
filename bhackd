#!/usr/bin/perl
#
# Licensed to the Apache Software Foundation (ASF) under one or or more
# contributor license agreements. See the NOTICE file distributed with this
# work for additional information regarding copyright ownership. The ASF
# licenses this file to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#

use FindBin;
use lib "$FindBin::Bin/lib";

use Mojolicious::Lite;
use Mojo::UserAgent;
use Mojo::Util qw(b64_decode b64_encode dumper);

use NetAddr::IP;
use Text::MultiMarkdown qw(markdown);
use Time::Piece;

use constant {
  CONFIG_PATH => $ENV{BHACKD_CONFIG} // '/etc/bhackd.conf'
};

my $ua = Mojo::UserAgent->new;

app->log->info('Configuration: ' . CONFIG_PATH);

#
# PLUGINS
#

plugin 'JSONConfig'          => {file => CONFIG_PATH};
plugin 'Plugins::Alarm'      => app->config->{alarm}    // {};
plugin 'Plugins::Calendar'   => app->config->{calendar} // {};
plugin 'Plugins::Device'     => app->config->{device}   // {};
plugin 'Plugins::Door'       => app->config->{door}     // {};
plugin 'Plugins::Jekyll'     => app->config->{blog}     // {};
plugin 'Plugins::Member'     => app->config->{members}  // {};
plugin 'Plugins::Meta'       => app->config->{meta}     // {};
plugin 'Plugins::RemoteIP';
plugin 'Plugins::TidyHQ'     => app->config->{tidyhq}   // {};

#
# HELPERS
#

helper 'is_local' => sub {
  my $c = shift;

  for my $hop (split /[, ]/, $c->req->headers->header('X-Forwarded-For') // '') {
    my $ip = NetAddr::IP->new($hop);
    return 1 if $ip && grep { $ip->within(NetAddr::IP->new($_)) } @{$c->app->config->{local}};
  }

  return undef;
};

helper 'is_not_dooropener' => sub {
  my $c = shift;
  my $bhack = $c->stash('bhack');

  return {'code' => 4001, 'error' => 'Inactive Membership'   } unless $c->tidyhq->has_active_membership({tidyhq => $bhack});
  return {'code' => 4002, 'error' => 'Insuffienct Membership'} unless $c->tidyhq->in_group('full-time members', {tidyhq => $bhack});
  return {'code' => 4003, 'error' => 'Unregistered Device'   } unless $c->device->is_whitelisted;

  return undef;
};

helper 'is_gatekeeper' => sub {
  my $c = shift;
  my $bhack = $c->stash('bhack');
  return undef unless $c->tidyhq->has_active_membership({tidyhq => $bhack});
  return undef unless $c->tidyhq->in_group('seeders', {tidyhq => $bhack});

  return 1;
};

#
# HOOKS
#

hook 'before_routes' => sub {
  my $c = shift;

  $c->stash(member => $c->member->find(email => $c->session('user')));
};

#
# ROUTES
#

get '/about'            => 'about';
get '/badges'           => 'badges';
get '/code-of-conduct'  => 'conduct';
get '/contact'          => 'contact';
get '/faq'              => 'faq';
get '/join'             => 'join';
get '/security'         => 'security';
get '/sponsors'         => 'sponsors';
get '/women'            => 'women';
get '/workshops'        => 'workshops';

get '/' => sub {
  my $c = shift;

  my $events = $c->events->list(16);
  $c->stash(events => $events);

  $c->render('index');
};

get '/blog' => sub {
  my $c = shift;

  my $tags = $c->param('tags');
  my $summary = $c->blog_summary(tags => $tags);

  $c->stash(summary => $summary, tags => $tags);
  $c->render('blog');
};

get '/blog/:date/:slug' => sub {
  my $c = shift;

  my $entry = $c->blog_parse_entry($c->param('date'), $c->param('slug'));

  if ($entry->{status} == 200) {
    $c->stash($entry);
    return $c->render('blog-entry');
  }

  $c->redirect_to('blog');
} => 'blog-entry';

post '/login' => sub {
  my $c = shift;

  my $json = $c->req->json;

  my $e   = $json->{email}    // $c->param('email');
  my $p   = $json->{password} // $c->param('password');
  my $url = $json->{rt}       // $c->param('rt') // 'index';

  $c->render_later;

  $c->member->login($e, $p)->then(sub {
    return $c->render(json => {'message' => 'success'}, status => 200);
  }, sub {
    my $error = shift;
    return $c->render(json => {'message' => $error}, status => 400);
  });
};

any '/logout' => sub {
  my $c = shift;

  $c->member->logout;

  # extract the redirect url and fall back to the index
  my $url = $c->param('rt') // 'index';

  return $c->redirect_to($url);
};

get '/model-rules' => sub {
  my $c = shift;

  $c->render_later;
  $ua->get('https://raw.githubusercontent.com/ballarat-hackerspace/association/master/rules-of-the-association.md' => sub {
    my ($ua, $tx) = @_;

    $c->stash(rules_content => markdown($tx->res->body));
    $c->render('modelrules');
  });
};

get '/patreon' => sub {
  shift->redirect_to('https://www.patreon.com/ballarathackerspace');
};


# interactive 'meta' portal
get '/meta' => sub {
  my $c = shift;

  my $streams = $c->meta->streams(itemsPerPage => 1);
  my $meta = $c->meta->find(itemsPerPage => 10);

  $c->stash(streams => $streams, meta => $meta);

  $c->render('meta');
};

get '/meta/space' => sub {
  my $c = shift;

  my $base_url = 'https://ballarathackerspace.org.au';

  $c->render(
    json => {
      api => 0.13,
      space => 'Ballarat Hackerspace',
      logo => "$base_url/images/bhack-logo-title-black.svg",
      url => "$base_url",
      location => {
        address => 'Top Floor, Building K (Ballarat Tech School), Federation University SMB Campus, Ballarat',
        lat => -37.565247,
        lon => 143.857645
      },
      contact => {
        email => 'committee@ballarathackerspace.org.au',
        twitter => 'bhackerspace'
      },
      projects => [
        'https://github.com/ballarat-hackerspace',
        'https://gitlab.com/ballarat-hackerspace',
      ]
    },
    status => 200
  );
} => 'spaceapi';

get '/meta/streams' => sub {
  my $c = shift;

  my $streams = $c->meta->streams;
  my $now = gmtime->epoch;

  $c->stash(streams => $streams);

  $c->respond_to(
    json => {json => {streams => $streams, ts => $now}},
    html => {template => 'meta-streams'},
  );
};

get '/meta/streams/:stream' => sub {
  my $c = shift;

  my $stream = $c->param('stream');
  my $itemsPerPage = $c->param('itemsPerPage');
  my $page = $c->param('page');

  $stream = '' if $stream eq '-';

  my $data = $c->meta->find(stream => $stream, itemsPerPage => $itemsPerPage, page => $page);

  my $format = $c->stash('format') // 'html';

  if ($format eq 'csv') {
    $data = $c->meta->to_csv($data);
  } elsif ($format eq 'html') {
    $c->stash(stream => $stream, meta => $data);
  }

  $c->respond_to(
    csv  => {text => $data},
    json => {json => $data},
    html => {template => 'meta-stream'},
  );
} => 'meta-stream';


post '/meta/streams' => sub {
  my $c = shift;

  my $json = $c->req->json;

  my $stream   = $json->{stream}   // $c->param('stream') // '';
  my $type     = $json->{type}     // $c->param('type');
  my $lifetime = $json->{lifetime} // $c->param('lifetime');
  my $data     = $json->{data}     // $c->param('data');

  my $now = gmtime->epoch;

  # validate stream name
  unless ($stream eq '' || $stream =~ m/[0-9a-zA-Z]{1,32}/) {
    return $c->render(
      json => {message => 'Stream name is invalid.', ts => $now},
      status => 400
    );
  }

  if (defined($data)) {
    my $meta = {
      ip => $c->remote_ip->addr,
    };

    if (ref($data) ne 'HASH') {
      return $c->render(
        json => {
          message => 'The specified data is not valid JSON.',
          ts => $now
        },
        status => 400
      );
    }

    $c->meta->publish(
      stream   => $stream,
      type     => $type,
      lifetime => $lifetime,
      data     => $data,
      meta     => $meta
    );

    return $c->render(
      json => {message => 'Congratulations!', ts => gmtime->epoch},
      status => 200
    );
  }

  return $c->render(
    json => {
      message => 'Some required parameters were missing.',
      ts => $now
    },
    status => 400
  );
};

# members only
group {
  under '/members' => sub {
    my $c = shift;

    # stash for later
    $c->stash('uuid' => $c->device->uuid);

    return 1 if $c->tidyhq->is_authenticated;

    $c->redirect_to('/');

    return undef;
  };

  get '/' => 'members';

  # device management
  get '/devices' => sub {
    my $c = shift;

    $c->stash(devices => $c->device->find);
    $c->render('members-devices');
  } => 'members-devices';

  post '/devices/add' => sub {
    my $c = shift;

    $c->device->add(
      uuid   => $c->param('uuid'),
      email  => $c->param('email'),
      device => $c->param('device')
    );
    $c->redirect_to('members-devices');
  } => 'members-devices-add';

  get '/devices/remove/:id' => sub {
    my $c = shift;

    $c->device->remove($c->param('id'));
    $c->redirect_to('members-devices');
  } => 'members-devices-remove';

  get '/workshops' => 'members-workshops';
};

# local network only
group {
  under '/local' => sub {
    my $c = shift;
    return 1 if $c->is_local;
    return $c->redirect_to('/');
  };

  get '/boiler' => 'boiler';
};

# door endpoints require additional device whitelisting checks
group {
  under '/door' => sub {
    my $c = shift;

    # stash for later
    $c->stash('uuid' => $c->device->uuid);

    return 1 if $c->is_local || $c->is_gatekeeper;

    $c->redirect_to('/');

    return undef;
  };

  get '/' => 'door';
  get '/access' => sub {
    my $c = shift;

    if (my $status = $c->is_not_dooropener) {
      return $c->render(status => 403, json => $status);
    }

    $c->render(json => {code => 2000, pong => $c->device->is_whitelisted});
  };

  get '/enter' => sub {
    my $c = shift;

    if (my $status = $c->is_not_dooropener) {
      return $c->render(status => 403, json => $status);
    }

    $c->render_later;
    $c->door->enter(
      device => $c->device->is_whitelisted,
      sub { shift; $c->render(status => shift, json => shift); }
    );
  };

  get '/open'  => sub {
    my $c = shift;

    if (my $status = $c->is_not_dooropener) {
      return $c->render(status => 403, json => $status);
    }

    $c->render_later;
    $c->door->open(
      device => $c->device->is_whitelisted,
      sub { shift; $c->render(status => shift, json => shift); }
    );
  };

  get '/close' => sub {
    my $c = shift;

    if (my $status = $c->is_not_dooropener) {
      return $c->render(status => 403, json => $status);
    }

    $c->render_later;
    $c->door->close(
      device => $c->device->is_whitelisted,
      sub { shift; $c->render(status => shift, json => shift); }
    );
  };
};

group {
  under '/alarm' => sub {
    my $c = shift;

    # stash for later
    $c->stash('uuid' => $c->device->uuid);

    return 1 if $c->is_local || $c->is_gatekeeper;
    return $c->redirect_to('/');
  };

  get '/disable' => sub {
    my $c = shift;

    if (my $status = $c->is_not_dooropener) {
      return $c->render(status => 403, json => $status);
    }

    $c->render_later;
    $c->alarm->disable(
      duration => $c->param('for'),
      sub { shift; $c->render(status => shift, json => shift); }
    );
  };
  get '/enable' => sub {
    my $c = shift;

    if (my $status = $c->is_not_dooropener) {
      return $c->render(status => 403, json => $status);
    }

    $c->render_later;
    $c->alarm->enable(
      sub { shift; $c->render(status => shift, json => shift); }
    );
  };
};

any '/*catch' => {catch => ''} => sub { shift->redirect_to('/'); };

app->secrets(app->config->{secrets});
app->start;

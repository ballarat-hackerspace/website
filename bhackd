#!/usr/bin/perl
#
# Licensed to the Apache Software Foundation (ASF) under one or or more
# contributor license agreements. See the NOTICE file distributed with this
# work for additional information regarding copyright ownership. The ASF
# licenses this file to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#

use FindBin;
use lib "$FindBin::Bin/lib";

use Mojolicious::Lite;
use Mojo::UserAgent;
use Mojo::Util qw(dumper);
use NetAddr::IP;
use Time::Piece;


use Plugins::Jekyll;

plugin 'JSONConfig'      => {file => '/etc/bhackd.conf'};
plugin 'Plugins::Device' => app->config->{device} // {};
plugin 'Plugins::Door'   => app->config->{door}   // {};
plugin 'Plugins::Jekyll' => app->config->{blog}   // {};
plugin 'Plugins::TidyHQ' => app->config->{tidyhq} // {};

app->secrets(app->config->{secrets});

helper 'is_local' => sub {
  my $c = shift;

  for my $hop (split /[, ]/, $c->req->headers->header('X-Forwarded-For') // '') {
    my $ip = NetAddr::IP->new($hop);
    return 1 if grep { $ip->within(NetAddr::IP->new($_)) } @{$c->app->config->{local}};
  }

  return undef;
};

helper 'is_dooropener' => sub {
  return 1 if shift->tidyhq->is_authenticated_group('workshop members');
  return undef;
};

helper 'is_gatekeeper' => sub {
  return 1 if shift->tidyhq->is_authenticated_group('seeders');
  return undef;
};

get '/'           => 'index';
get '/about'      => 'about';
get '/faq'      => 'faq';
get '/conduct'    => 'conduct';
get '/contact'    => 'contact';
get '/join'       => 'join';
get '/sponsors'   => 'sponsors';
get '/workshops'  => 'workshops';
get '/security'   => 'security';

get '/blog' => sub {
  my $c = shift;

  my $tags = $c->param('tags');
  my $summary = $c->blog_summary(tags => $tags);

  $c->stash(summary => $summary, tags => $tags);
  $c->render('blog');
};

get '/blog/:date/:slug' => sub {
  my $c = shift;

  my $entry = $c->blog_parse_entry($c->param('date'), $c->param('slug'));

  if ($entry->{status} == 200) {
    $c->stash($entry);
    return $c->render('blog-entry');
  }

  $c->redirect_to('blog');
} => 'blog-entry';

post '/login' => sub {
  my $c = shift;

  my $e   = $c->param('email');
  my $p   = $c->param('password');
  my $url = $c->param('rt') // 'index';

  $c->render_later;
  $c->tidyhq->login(email => $e, password => $p, sub {
    return $c->redirect_to($url);
  });
};

any '/logout' => sub {
  my $c = shift;

  $c->tidyhq->logout;

  # extract the redirect url and fall back to the index
  my $url = $c->param('rt') // 'index';

  return $c->redirect_to($url);
};

# members only
group {
  under '/members' => sub {
    my $c = shift;

    # stash for later
    $c->stash('uuid' => $c->device->uuid);

    return 1 if $c->tidyhq->is_authenticated;
    return $c->redirect_to('/');
  };

  get '/' => 'members';

  # device management
  get '/devices' => sub {
    my $c = shift;
    $c->stash(devices => $c->device->find);
    $c->render('members-devices');
  } => 'members-devices';

  post '/devices/add' => sub {
    my $c = shift;

    $c->device->add(
      uuid   => $c->param('uuid'),
      email  => $c->param('email'),
      device => $c->param('device')
    );
    $c->redirect_to('members-devices');
  } => 'members-devices-add';

  get '/devices/remove/:id' => sub {
    my $c = shift;

    $c->device->remove($c->param('id'));
    $c->redirect_to('members-devices');
  } => 'members-devices-remove';
};

# local network only
group {
  under '/local' => sub {
    my $c = shift;
    return 1 if $c->is_local;
    return $c->redirect_to('/');
  };

  get '/boiler' => 'boiler';
};

# door endpoints require additional device whitelisting checks
group {
  under '/door' => sub {
    my $c = shift;

    # stash for later
    $c->stash('uuid' => $c->device->uuid);

    return 1 if $c->is_local || $c->is_gatekeeper;
    return $c->redirect_to('/');
  };

  get '/' => 'door';
  get '/access' => sub {
    my $c = shift;
    return $c->render(status => 403, json => '') unless $c->is_dooropener && $c->device->is_whitelisted;

    $c->render(json => {pong => $c->device->is_whitelisted});
  };

  get '/enter' => sub {
    my $c = shift;
    return $c->render(status => 403, json => '') unless $c->is_dooropener && $c->device->is_whitelisted;

    $c->render_later;
    $c->door->enter(
      device => $c->device->is_whitelisted,
      sub { shift; $c->render(status => shift, json => shift); }
    );
  };

  get '/open'  => sub {
    my $c = shift;
    return $c->render(status => 403, json => '') unless $c->is_dooropener && $c->device->is_whitelisted;

    $c->render_later;
    $c->door->open(
      device => $c->device->is_whitelisted,
      sub { shift; $c->render(status => shift, json => shift); }
    );
  };

  get '/close' => sub {
    my $c = shift;
    return $c->render(status => 403, json => '') unless $c->is_dooropener && $c->device->is_whitelisted;

    $c->render_later;
    $c->door->close(
      device => $c->device->is_whitelisted,
      sub { shift; $c->render(status => shift, json => shift); }
    );
  };
};

any '/*catch' => {catch => ''} => sub { shift->redirect_to('/'); };

app->start;
